<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Trace Letter b continuously</title>
<link href="https://fonts.googleapis.com/css2?family=Lexend&display=swap" rel="stylesheet" />
<style>
  body {
    font-family: 'Lexend', sans-serif;
    background: #f0f8ff;
    text-align: center;
    margin: 20px;
    user-select: none;
  }
  h1 {
    margin-bottom: 10px;
  }
  canvas {
    border: 2px solid #333;
    background: white;
    touch-action: none;
    display: block;
    margin: 0 auto 10px auto;
  }
  #progress {
    font-size: 20px;
    margin-bottom: 5px;
  }
  #strokeInfo {
    font-size: 18px;
    color: #555;
  }
  #message {
    font-size: 24px;
    font-weight: bold;
    color: green;
    min-height: 40px;
    margin-top: 15px;
  }
</style>
</head>
<body>

<h1>Trace the letter: b</h1>
<div id="progress">Trace count: 0 / 1</div>
<div id="strokeInfo">Trace both strokes continuously</div>
<canvas id="traceCanvas" width="500" height="400"></canvas>
<div id="message"></div>

<script>
const canvas = document.getElementById('traceCanvas');
const ctx = canvas.getContext('2d');
const progress = document.getElementById('progress');
const strokeInfo = document.getElementById('strokeInfo');
const message = document.getElementById('message');

ctx.lineCap = 'round';
ctx.lineJoin = 'round';

const fontSize = 220;
const letterX = 250;
const letterY = 200;

const radius = 12;
const minPointsForStroke = 10;

let isDrawing = false;
let traceCount = 0;
let completed = false;

// Track which strokes have been traced in this drawing session
let stroke1Points = new Set();
let stroke2Points = new Set();

const strokes = [
  {
    name: 'vertical line',
    start: {x: 209.0, y: 112.0},
    end: {x: 208.0, y: 256.0},
    draw(ctx) {
      ctx.beginPath();
      ctx.lineWidth = 8;
      ctx.strokeStyle = 'black';
      ctx.moveTo(this.start.x, this.start.y);
      ctx.lineTo(this.end.x, this.end.y);
      ctx.stroke();
    },
    isPointNearStroke(pos) {
      const x = pos.x;
      const y = pos.y;
      if (y < this.start.y - radius || y > this.end.y + radius) return false;
      return Math.abs(x - this.start.x) <= radius;
    }
  },
  {
    name: 'bottom bump',
    start1: {x: 206.0, y: 206.0},
    cp1: {x: 262.0, y: 99.0},
    end1: {x: 303.0, y: 211.0},
    start2: {x: 302.0, y: 211.0},
    cp2: {x: 250.0, y: 314.0},
    end2: {x: 205.0, y: 207.0},
    draw(ctx) {
      ctx.beginPath();
      ctx.lineWidth = 8;
      ctx.strokeStyle = 'black';
      ctx.moveTo(this.start1.x, this.start1.y);
      ctx.quadraticCurveTo(this.cp1.x, this.cp1.y, this.end1.x, this.end1.y);
      ctx.quadraticCurveTo(this.cp2.x, this.cp2.y, this.end2.x, this.end2.y);
      ctx.stroke();
    },
    isPointNearStroke(pos) {
      const checkPoints = [];
      for (let t = 0; t <= 1; t += 0.05) {
        const x = (1 - t)*(1 - t)*this.start1.x + 2*(1 - t)*t*this.cp1.x + t*t*this.end1.x;
        const y = (1 - t)*(1 - t)*this.start1.y + 2*(1 - t)*t*this.cp1.y + t*t*this.end1.y;
        checkPoints.push({x, y});
      }
      for (let t = 0; t <= 1; t += 0.05) {
        const x = (1 - t)*(1 - t)*this.start2.x + 2*(1 - t)*t*this.cp2.x + t*t*this.end2.x;
        const y = (1 - t)*(1 - t)*this.start2.y + 2*(1 - t)*t*this.cp2.y + t*t*this.end2.y;
        checkPoints.push({x, y});
      }
      for (const pt of checkPoints) {
        const dx = pos.x - pt.x;
        const dy = pos.y - pt.y;
        if (Math.sqrt(dx*dx + dy*dy) <= radius) return true;
      }
      return false;
    }
  }
];

function drawArrow(startX, startY, endX, endY, color = 'blue') {
  const headlen = 12;
  const dx = endX - startX;
  const dy = endY - startY;
  const angle = Math.atan2(dy, dx);
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(endX, endY);
  ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI / 6), endY - headlen * Math.sin(angle - Math.PI / 6));
  ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI / 6), endY - headlen * Math.sin(angle + Math.PI / 6));
  ctx.lineTo(endX, endY);
  ctx.fill();
}

function drawQuadraticArrow(startX, startY, cpX, cpY, endX, endY, color = 'blue') {
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.quadraticCurveTo(cpX, cpY, endX, endY);
  ctx.stroke();

  const t = 0.9;
  const dx = 2*(1 - t)*(cpX - startX) + 2*t*(endX - cpX);
  const dy = 2*(1 - t)*(cpY - startY) + 2*t*(endY - cpY);
  const angle = Math.atan2(dy, dx);

  const headlen = 12;
  ctx.beginPath();
  ctx.moveTo(endX, endY);
  ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI/6), endY - headlen * Math.sin(angle - Math.PI/6));
  ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI/6), endY - headlen * Math.sin(angle + Math.PI/6));
  ctx.lineTo(endX, endY);
  ctx.fill();
}

function drawLetter() {
  ctx.font = fontSize + "px Lexend, sans-serif";
  ctx.fillStyle = 'black';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('b', letterX, letterY);
}

function drawGuides() {
  drawArrow(strokes[0].start.x, strokes[0].start.y, strokes[0].end.x, strokes[0].end.y);

  ctx.fillStyle = 'blue';
  ctx.font = "28px Lexend, sans-serif";
  ctx.fillText('1', strokes[0].start.x - 30, strokes[0].start.y - 10);

  drawQuadraticArrow(strokes[1].start1.x, strokes[1].start1.y, strokes[1].cp1.x, strokes[1].cp1.y, strokes[1].end1.x, strokes[1].end1.y);
  drawQuadraticArrow(strokes[1].start2.x, strokes[1].start2.y, strokes[1].cp2.x, strokes[1].cp2.y, strokes[1].end2.x, strokes[1].end2.y);

  ctx.fillText('2', strokes[1].start1.x - 30, strokes[1].start1.y - 10);
}

function resetCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawLetter();
  drawGuides();
}

function speak(text) {
  const synth = window.speechSynthesis;
  if (synth.speaking) synth.cancel();
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = "en-US";
  synth.speak(utter);
}

function updateProgress() {
  progress.textContent = `Trace count: ${traceCount} / 1`;
}

function giveFeedback(correct) {
  if (correct) {
    message.style.color = 'green';
    message.textContent = 'Good job! Well done!';
  } else {
    message.style.color = 'red';
    message.textContent = 'Try again, trace both strokes continuously.';
  }
}

function startDrawing(e) {
  if (completed) return;
  e.preventDefault();
  isDrawing = true;
  stroke1Points.clear();
  stroke2Points.clear();
  ctx.beginPath();
  const pos = getPointerPos(e);
  ctx.moveTo(pos.x, pos.y);
  checkStrokes(pos);
  message.textContent = '';
}

function draw(e) {
  if (completed) return;
  if (!isDrawing) return;
  e.preventDefault();
  const pos = getPointerPos(e);
  ctx.lineWidth = 8;
  ctx.lineCap = 'round';
  ctx.strokeStyle = 'blue';
  ctx.lineTo(pos.x, pos.y);
  ctx.stroke();
  checkStrokes(pos);
}

function stopDrawing(e) {
  if (completed) return;
  if (!isDrawing) return;
  e.preventDefault();
  isDrawing = false;
  ctx.closePath();

  // Check if both strokes have enough points traced
  if (stroke1Points.size >= minPointsForStroke && stroke2Points.size >= minPointsForStroke) {
    traceCount++;
    updateProgress();
    giveFeedback(true);
    speak('Good job! Well done!');
    completed = true;
  } else {
    giveFeedback(false);
    speak('Try again, trace both strokes continuously.');
  }
  resetCanvas();
}

function getPointerPos(evt) {
  const rect = canvas.getBoundingClientRect();
  const x = (evt.clientX !== undefined) ? evt.clientX : evt.touches[0].clientX;
  const y = (evt.clientY !== undefined) ? evt.clientY : evt.touches[0].clientY;
  return {x: x - rect.left, y: y - rect.top};
}

function checkStrokes(pos) {
  if (strokes[0].isPointNearStroke(pos)) {
    stroke1Points.add(`${Math.floor(pos.x)}_${Math.floor(pos.y)}`);
  }
  if (strokes[1].isPointNearStroke(pos)) {
    stroke2Points.add(`${Math.floor(pos.x)}_${Math.floor(pos.y)}`);
  }
}

resetCanvas();
updateProgress();
speak('Trace the letter continuously.');

canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', stopDrawing);
canvas.addEventListener('mouseleave', stopDrawing);

canvas.addEventListener('touchstart', startDrawing);
canvas.addEventListener('touchmove', draw, {passive:false});
canvas.addEventListener('touchend', stopDrawing);

</script>

</body>
</html>
